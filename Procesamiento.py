# -*- coding: utf-8 -*-
"""Método_Biodi2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aMcn0KwCEJwsT0xLFD0RsGfCV1J39vez
"""

# Script completo para detección, filtrado, corrección y digitalización de puntos

import cv2
import numpy as np
from scipy.ndimage import gaussian_filter
from sklearn.cluster import DBSCAN, KMeans
from matplotlib import pyplot as plt


# --- Paso 0: Montar Drive y cargar imagen ---

image_path = "ojo_derecho_gabs.jpg"
img_color = cv2.imread(image_path)
img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# --- Paso 1: Ecualización e inversión ---
img_eq = cv2.equalizeHist(img)
img_inv = cv2.bitwise_not(img_eq)

# --- Paso 2: Suavizado ---
img_blur = gaussian_filter(img_inv, sigma=0.8)

# --- Paso 3: Detección inicial con HoughCircles (para extraer template) ---
circles = cv2.HoughCircles(
    img_blur.astype(np.uint8),
    cv2.HOUGH_GRADIENT,
    dp=1.2,
    minDist=10,#10
    param1=30,
    param2=8,
    minRadius=3,
    maxRadius=5
)

if circles is None:
    raise RuntimeError("No se detectaron círculos Hough para usar como template.")

# Extraer primer círculo como kernel
circles = np.uint16(np.around(circles))
x0, y0, r0 = circles[0][0]
patch_size = 2*r0 + 1
template = img_blur[y0-r0:y0+r0+1, x0-r0:x0+r0+1].astype(np.float32)
template = (template - template.mean()) / (template.std() + 1e-5)

# --- Paso 4: Template Matching ---
img_norm = img_blur.astype(np.float32)
img_norm = (img_norm - img_norm.mean()) / (img_norm.std() + 1e-5)
result = cv2.matchTemplate(img_norm, template, cv2.TM_CCOEFF_NORMED)

# Umbralizado de coincidencias
threshold = 0.55
ys, xs = np.where(result >= threshold)
points = list(zip(xs, ys))

# --- Paso 5: Agrupación para evitar duplicados ---
clustering = DBSCAN(eps=r0, min_samples=1).fit(np.array(points))
labels = clustering.labels_
unique_labels = np.unique(labels)

# --- Paso 6: Corrección de offset del template ---
offset = (template.shape[1]//2, template.shape[0]//2)
corrected_points = []
for lbl in unique_labels:
    pts = np.array(points)[labels == lbl]
    mean_pt = pts.mean(axis=0)
    corrected = mean_pt + np.array(offset)
    corrected_points.append(tuple(corrected.astype(int)))

# --- Paso 7: Filtrado por ROI (zona válida) ---
corrected = np.array(corrected_points)
x_min, x_max = 30,450
y_min, y_max = 40,270
mask = (
    (corrected[:,0] >= x_min) & (corrected[:,0] <= x_max) &
    (corrected[:,1] >= y_min) & (corrected[:,1] <= y_max)
)
filtered = corrected[mask]
x_real, y_real = filtered[:,0], filtered[:,1]

# Resultado: número de puntos detectados
print(f"Total puntos detectados (filtrados): {len(filtered)}")

# --- Paso 8: Centrado y cálculo de polar ---
center_x, center_y = 165,165 # centro aproximado del iris
x_c = x_real - center_x
y_c = y_real - center_y
r = np.sqrt(x_c**2 + y_c**2)
theta = np.arctan2(y_c, x_c)

# --- Paso 9: Clasificación por anillos (KMeans en radio) ---
num_rings = 30
kmeans = KMeans(n_clusters=num_rings, random_state=0).fit(r.reshape(-1,1))
ring_labels = kmeans.labels_

# Reconstrucción digital de puntos
digital_x, digital_y = [], []
for ring_id in range(num_rings):
    idx = np.where(ring_labels == ring_id)[0]
    r_mean = r[idx].mean()
    angles = np.sort(theta[idx])
    for ang in angles:
        digital_x.append(r_mean*np.cos(ang) + center_x)
        digital_y.append(r_mean*np.sin(ang) + center_y)

# --- Paso 10: Visualización final ---

# Dibujar detecciones sobre imagen a color
img_out = img_color.copy()
for (x, y) in filtered:
    cv2.circle(img_out, (x, y), 2, (0, 0, 255), 1)

plt.figure(figsize=(6,6))
plt.imshow(cv2.cvtColor(img_out, cv2.COLOR_BGR2RGB))
plt.title(f"Puntos detectados: {len(filtered)}")
plt.axis('off')

# Comparativa de posición real vs digitalizada
plt.figure(figsize=(6,6))
plt.scatter(x_real, y_real, s=10, label='Reales', alpha=0.7)
#plt.scatter(digital_x, digital_y, s=10, label='Digitalizados', alpha=0.7)
plt.axis('equal')
plt.legend()
plt.title("Real vs Digitalizado")
plt.show()

"""Meridianos"""

import numpy as np
import matplotlib.pyplot as plt

# -----------------------------
# Parámetros
# -----------------------------
center_x, center_y = 163, 145  # centro óptico (en píxeles)
scale = 0.03  # conversión de píxeles a cm

# -----------------------------
# Convertir puntos reales a físico (cm)
# -----------------------------
# Supón que tienes x_real e y_real ya definidos (arrays de puntos)
x_cm = (x_real - center_x) * scale
y_cm = (y_real - center_y) * scale
real_points_cm = np.stack((x_cm, y_cm), axis=1)

# -----------------------------
# Función de filtrado
# -----------------------------
def filtrar_por_meridiano(real_points_cm, meridiano_deg, tolerance_cm=0.15):
    angle_rad = np.radians(meridiano_deg)
    direction = np.array([np.cos(angle_rad), np.sin(angle_rad)])
    projections = np.dot(real_points_cm, direction)
    projected = np.outer(projections, direction)
    dist_perpendicular = np.linalg.norm(real_points_cm - projected, axis=1)
    mask = dist_perpendicular <= tolerance_cm
    puntos_cercanos = real_points_cm[mask]
    proyecciones_centrales = projections[mask]
    indices_ordenados = np.argsort(proyecciones_centrales)
    puntos_ordenados = puntos_cercanos[indices_ordenados]
    return puntos_ordenados

# -----------------------------
# Meridianos a evaluar
# -----------------------------
meridianos = [0, 22, 67, 45, 92, 115, 136, 158]
tolerance = 0.17

# Diccionario para guardar los puntos por meridiano
puntos_por_meridiano = {}

# Recorrer meridianos y guardar puntos
for m in meridianos:
    puntos = filtrar_por_meridiano(real_points_cm, meridiano_deg=m, tolerance_cm=tolerance)
    puntos = puntos[np.linalg.norm(puntos, axis=1) <= 5.5]  # limitar por radio
    puntos_por_meridiano[m] = puntos

# Ahora tienes todos los puntos guardados por ángulo
# Ejemplo: acceder a puntos del meridiano 67°
df_0= puntos_por_meridiano[0]
df_22 = puntos_por_meridiano[22]
df_45 = puntos_por_meridiano[45]
df_67 = puntos_por_meridiano[67]
df_90 = puntos_por_meridiano[92]
df_112 = puntos_por_meridiano[115]
df_135 = puntos_por_meridiano[136]
df_157 = puntos_por_meridiano[158]
df_90

R = 7.8  # en cm
elevaciones_por_meridiano = {}

for meridiano, puntos in puntos_por_meridiano.items():
    if meridiano == 90:
        y_vals = puntos[:, 1]  # usar columna x como eje vertical
    if meridiano == 0:
        y_vals = puntos[:, 0]
    else:
        y_vals = puntos[:, 1]  # eje radial general también es x (en eje horizontal)

    z_teorico = 2*(y_vals**2) / (2 * R)
    elevaciones_por_meridiano[meridiano] = {
        'y': y_vals,
        'z': z_teorico
    }

    # Graficar
    plt.figure(figsize=(6, 4))
    plt.plot(y_vals, z_teorico, label=f'Meridiano {meridiano}°', marker='o')
    plt.title(f"Elevación corneal teórica - Meridiano {meridiano}°")
    plt.xlabel("y (cm)")
    plt.ylabel("z (cm)")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

"""Elevación"""

import re
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata

# Leer el archivo de texto
with open('perfiles_corneales2_ordenado.txt', 'r') as file:
    text = file.read()

# Extraer bloques por meridiano
pattern = r'df_(\d+):([^d]*)'
tokens = re.findall(pattern, text)

# Crear diccionario de datos
data = {}
for angle, content in tokens:
    # Extraer pares y, z
    pairs = re.findall(r'y\s*=\s*([-\d.]+)\s*,\s*z\s*=\s*([-\d.]+)', content)
    values = np.array([[float(y), float(z)] for y, z in pairs])
    data[f'df_{angle}'] = values

# Acceso a los datos
y_0 = data['df_0'][:, 0]
z_0 = data['df_0'][:, 1]

# Conversión a coordenadas polares
meridianos = ['df_0', 'df_22', 'df_45', 'df_67', 'df_90', 'df_112', 'df_135', 'df_157']
angulos = [0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5]  # en grados

xAll, yAll, zAll = [], [], []
for nombre, theta_deg in zip(meridianos, angulos):
    theta = np.radians(theta_deg)
    datos = data[nombre]
    r = datos[:, 0]
    z = datos[:, 1]
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    xAll.extend(x)
    yAll.extend(y)
    zAll.extend(z)

xAll = np.array(xAll)
yAll = np.array(yAll)
zAll = np.array(zAll)
zAll_adj = -zAll + 1

# Interpolación 2D
xq, yq = np.meshgrid(
    np.linspace(xAll.min(), xAll.max(), 200),
    np.linspace(yAll.min(), yAll.max(), 200)
)
zq = griddata((xAll, yAll), zAll_adj, (xq, yq), method='cubic')

# Visualización con surf
fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(xq, yq, zq, cmap='jet', edgecolor='none')
fig.colorbar(surf)
ax.set_xlabel('X (mm)')
ax.set_ylabel('Y (mm)')
ax.set_zlabel('Elevación (mm)')
ax.set_title('Mapa de Elevación Corneal con surf')
ax.view_init(elev=30, azim=135)

# Puntos originales
ax.scatter(xAll, yAll, zAll_adj, color='red', s=8)
plt.tight_layout()
plt.show()

"""#MAPA TANGENCIAL"""

import re

# ----------------------------------------------- PASO 1: EXTRACCIÓN DEL PERFIL CORNEAL z(r) SOBRE CADA MERIDIANO -----------------------------------------------
# Aquí almacenamos los perfiles directamente
perfiles = {}

# Reemplazamos el archivo con las listas generadas en el código completo
# Los valores de "y" y "z" ya están disponibles, por lo que simplemente se agregan a la estructura de datos de los perfiles.

# Asegurémonos de tener las listas de puntos "y" y "z" para cada meridiano (estos ya están calculados en el paso 4, después de DBSCAN)
for meridiano, datos in puntos_por_meridiano.items():
    # Datos de cada meridiano "y" y "z"
    y_vals = datos[:, 0]  # Coordenadas "y"
    z_vals = datos[:, 1]  # Coordenadas "z"

    # Almacenamos los valores "y" y "z" en la estructura de perfiles
    perfiles[meridiano] = {"y": y_vals.tolist(), "z": z_vals.tolist()}

# Confirmamos las claves cargadas
print("Meridianos cargados:", list(perfiles.keys()))

# Confirmamos que cada "y" y "z" está bien separado por meridiano
for meridiano, datos in perfiles.items():
    y_vals = datos["y"]
    z_vals = datos["z"]
    print(f"\nMeridiano: {meridiano}")
    print(f"Número de puntos: {len(y_vals)}")
    print(f"Primer punto: y = {y_vals[0]}, z = {z_vals[0]}")
    print(f"Último punto: y = {y_vals[-1]}, z = {z_vals[-1]}")

# ----------------------------------------------- PASO 2: GRAFICAMOS LOS MERIDIANOS -----------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
import re

num_meridianos = len(perfiles)
cols = 4
rows = int(np.ceil(num_meridianos / cols))

curvaturas = {}

fig, axs = plt.subplots(rows, cols, figsize=(5*cols, 4*rows), sharex=False, sharey=False)
axs = axs.flatten()

for i, (meridiano, datos) in enumerate(perfiles.items()):
    y = np.array(datos["y"])
    z = np.array(datos["z"])

    # Ordenar
    orden = np.argsort(y)
    y = y[orden]
    z = z[orden]

    # Invertir y trasladar
    z_invertido = -z
    z_trasladado = z_invertido + np.max(z)


# ----------------------------------------------- PASO 3: CALCULAMOS "KT": CURVATURAS -----------------------------------------------

    #APLICAMOS PRIMERA Y SEGUNDA DERIVADA PARA USAR LA FÓRMULA DE Kt
    dz = np.gradient(z_trasladado, y)
    d2z = np.gradient(dz, y)
    Kt = d2z / (1 + dz**2)**(3/2)

# ----------------------------------------------- PASO 4: CALCULAMOS LOS RADIOS DE CURVATURA Y POTENCIA TANGENCIAL EN DIOPTRÍAS (KTD) -----------------------------------------------

    n_cornea = 1.3375  # índice de refracción de la córnea (aire-córnea)

    #RADIO DE CURVATURA EN "mm"
    Rt = 1 / Kt

# ----------------------------------------------- PASO 5: CALCULAMOS LAS POTENCIAS TANGENCIALES EN DIOPTRÍAS (KTD) -----------------------------------------------

    #POTENCIA TANGENCIAL EN DIOPTRÍAS (D)
    Kt_D = -1000 * (n_cornea - 1) * Kt

    #GUARDAMOS CADA VALOR EN UNA LISTA
    curvaturas[meridiano] = {
        "y": y,
        "z": z_trasladado,
        "dz": dz,
        "d2z": d2z,
        "Kt": Kt,
        "Rt": Rt,
        "Kt_D": Kt_D
    }

    #GRAFICAMOS LOS MERIDIANOS
    axs[i].plot(y, z_trasladado, 'o-', label="Perfil z trasladado", alpha=0.6)
    axs[i].set_title(f"{meridiano}")
    axs[i].set_xlabel("y [mm]")
    axs[i].set_ylabel("z [mm] (pico = 0)")
    axs[i].legend()
    axs[i].grid(True)

for j in range(i+1, len(axs)):
    axs[j].axis("off")

plt.suptitle("Perfiles corneales")
plt.tight_layout()
plt.show()

print("✅ Cálculo de Kt y visualización completados.")

# ------------------------ GRAFICAMOS LAS CURVATURAS (Kt) -----------------------------
fig, axs = plt.subplots(rows, cols, figsize=(5*cols, 4*rows), sharex=False, sharey=False)
axs = axs.flatten()

for i, (meridiano, datos) in enumerate(curvaturas.items()):
    y = datos["y"]
    Kt = datos["Kt"]

    axs[i].plot(y, Kt, 'o-', color='orange', label="Kt [1/mm]")
    axs[i].set_title(f"{meridiano}")
    axs[i].set_xlabel("y [mm]")
    axs[i].set_ylabel("Kt [1/mm]")
    axs[i].legend()
    axs[i].grid(True)

for j in range(i+1, len(axs)):
    axs[j].axis("off")

plt.suptitle("Curvatura tangencial $K_t$ por meridiano")
plt.tight_layout()
plt.show()

# ------------------------ GRAFICAMOS LAS POTENCIAS TANGENCIALES EN DIOPTRÍAS (KtD) -----------------------------
fig, axs = plt.subplots(rows, cols, figsize=(5*cols, 4*rows))
axs = axs.flatten()

for i, (meridiano, datos) in enumerate(curvaturas.items()):
    y = datos["y"]
    Kt_D = datos["Kt_D"]

    axs[i].plot(y, Kt_D, 'o-', color='purple', label="Kt [D]")
    axs[i].set_title(f"{meridiano}")
    axs[i].set_xlabel("y [mm]")
    axs[i].set_ylabel("Potencia [D]")
    axs[i].legend()
    axs[i].grid(True)

for j in range(i+1, len(axs)):
    axs[j].axis("off")

plt.suptitle("Potencia tangencial (dioptrías) por meridiano")
plt.tight_layout()
plt.show()

#----------------------------------------------- VISUALIZACIÓN DEL MAPA TANGENCIAL -----------------------------------------------

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from scipy.interpolate import griddata
from scipy.ndimage import median_filter

# Crear los datos combinados
X_all, Y_all, Z_all = [], [], []

# Graficar cada meridiano con sus datos reales
fig, ax = plt.subplots(figsize=(8, 8))

# ----------------------------------------------- PASO 6. CONVERSIÓN POLAR A CARTESIANA: Convertimos los perfiles de cada meridiano (radiales) a un plano cartesiano 2D, asociando a cada punto su potencia tangencial “Ktd”. -----------------------------------------------

for i, (meridiano, datos) in enumerate(curvaturas.items()):
    angulo_deg = int(meridiano.replace("df_", ""))
    angulo_rad = np.radians(angulo_deg)

    y = np.array(datos["y"])
    Kt_D = np.array(datos["Kt_D"])

    # Coordenadas cartesianas para cada meridiano
    x_coords = y * np.cos(angulo_rad)
    y_coords = y * np.sin(angulo_rad)

    # Superponer líneas de meridianos sobre el mapa (activamos esto)
    ax.plot(x_coords, y_coords, linestyle='-', linewidth=1.0, color='red', alpha=0.8)

    # Agregar etiqueta del ángulo al final de cada meridiano
    ax.text(x_coords[-1]*1.05, y_coords[-1]*1.05, f'{angulo_deg}°', fontsize=9, color='black', ha='center', va='center')

    # Asegurarse de que los puntos se están agregando a las listas
    X_all.extend(x_coords)
    Y_all.extend(y_coords)
    Z_all.extend(Kt_D)

# Comprobamos si las listas X_all, Y_all, Z_all contienen datos
print(f"X_all: {len(X_all)} puntos")
print(f"Y_all: {len(Y_all)} puntos")
print(f"Z_all: {len(Z_all)} puntos")

# Asegurarse de que no están vacías
if len(X_all) == 0 or len(Y_all) == 0 or len(Z_all) == 0:
    print("Error: Las listas de puntos están vacías.")
else:

# ----------------------------------------------- PASO 7. INTERPOLAMOS EN MALLA REGULAR -----------------------------------------------
    # Crear malla regular para el mapa de contorno
    X_all = np.array(X_all)
    Y_all = np.array(Y_all)
    Z_all = np.array(Z_all)

    grid_res = 200
    xi = np.linspace(-5, 5, grid_res)
    yi = np.linspace(-5, 5, grid_res)
    Xgrid, Ygrid = np.meshgrid(xi, yi)

    # INTERPOLACIÓN CÚBUICA CON GRIDDATA
    Zgrid = griddata((X_all, Y_all), Z_all, (Xgrid, Ygrid), method='cubic')

# ----------------------------------------------- PASO 8. FILTRAMOS Y VISUALIZAMOS EL MAPA TANGENCIAL -----------------------------------------------

    # Filtrar el mapa
    Zgrid_filtrado = median_filter(Zgrid, size=4)

    # Mapa de contorno
    contour = ax.contourf(Xgrid, Ygrid, Zgrid_filtrado, levels=np.linspace(0, 90, 20), cmap='jet') #
    cbar = plt.colorbar(contour, ax=ax)
    cbar.set_label("Potencia tangencial [D]")

    # Títulos y etiquetas
    ax.set_title("Tangential curvature (Front)", fontsize=14)
    ax.set_xlabel("X [mm]")
    ax.set_ylabel("Y [mm]")
    ax.axis('equal')
    ax.grid(False)

    # Líneas radiales cada 30° en rojo
    #for ang in range(0, 360, 30):
     #   angle_rad = np.radians(ang)

        # Colocar el grado en la esquina de cada línea radial
       # ax.text(5.2 * np.cos(angle_rad), 5.2 * np.sin(angle_rad), f'{ang}°', color='black', fontsize=11, ha='center', va='center')

    # Círculos concéntricos cada 1 mm
    for r in range(1, 6):
        circ = Circle((0, 0), r, fill=False, color='gray', linestyle=':', linewidth=0.8)
        ax.add_patch(circ)

    plt.tight_layout()
    plt.show()